import os
import re
import sys
import json
import logging
import argparse

import openai
import tiktoken

logger = logging.getLogger(__name__)
logging.basicConfig(
    format="%(asctime)s - %(funcName)s() - %(message)s",
    datefmt="%Y/%m/%d %H:%M:%S",
    level=logging.INFO,
)

# -------------------- IO utils --------------------
def read_txt(file, write_log=False):
    if write_log:
        logger.info(f"Reading {file}")
    with open(file, "r", encoding="utf8") as f:
        text = f.read()
    if write_log:
        logger.info(f"Read {len(text):,} characters")
    return text


def write_txt(file, text, write_log=False):
    if write_log:
        logger.info(f"Writing {len(text):,} characters to {file}")
    with open(file, "w", encoding="utf8") as f:
        f.write(text)
    if write_log:
        logger.info("Written")
    return


def read_json(file, write_log=False):
    if write_log:
        logger.info(f"Reading {file}")
    with open(file, "r", encoding="utf8") as f:
        data = json.load(f)
    if write_log:
        logger.info(f"Read {len(data):,} objects")
    return data


def write_json(file, data, indent=None, write_log=False):
    if write_log:
        logger.info(f"Writing {len(data):,} objects to {file}")
    with open(file, "w", encoding="utf8") as f:
        json.dump(data, f, indent=indent, ensure_ascii=False)
    if write_log:
        logger.info("Written")
    return


# -------------------- Config --------------------
class Config:
    def __init__(self, config_file):
        data = read_json(config_file)
        self.model = data["model"]
        self.static_dir = os.path.join(*data["static_dir"])
        self.state_dir = os.path.join(*data["state_dir"])
        self.output_dir = os.path.join(*data["output_dir"])

        os.makedirs(self.state_dir, exist_ok=True)
        os.makedirs(self.output_dir, exist_ok=True)
        return


# -------------------- GPT Wrapper --------------------
class GPT:
    def __init__(self, model):
        self.model = model
        self.tokenizer = tiktoken.encoding_for_model(self.model)
        self.model_candidate_tokens = {
            "gpt-3.5-turbo": {
                "gpt-3.5-turbo": 4096,
                "gpt-3.5-turbo-16k": 16384,
            },
            "gpt-4": {
                "gpt-4": 8192,
                "gpt-4-32k": 32768,
            },
            "gpt-4.1": {
                "gpt-4.1": 8192,
            }
        }
        return

    def get_specific_tokens_model(self, text_in, out_tokens):
        in_token_list = self.tokenizer.encode(text_in)
        in_tokens = len(in_token_list)
        tokens = in_tokens + out_tokens

        for candidate, max_tokens in self.model_candidate_tokens.get(self.model, {}).items():
            if max_tokens >= tokens:
                break
        else:
            candidate = ""

        return in_tokens, candidate

    def run_gpt(self, text_in, out_tokens):
        in_tokens, specific_tokens_model = self.get_specific_tokens_model(text_in, out_tokens)
        if not specific_tokens_model:
            return ""

        logger.info("Calling OpenAI...")
        completion = openai.ChatCompletion.create(
            model=specific_tokens_model,
            n=1,
            messages=[{"role": "user", "content": text_in}],
            temperature=0.8
        )
        text_out = completion.choices[0].message.content
        return text_out


# -------------------- State --------------------
class State:
    def __init__(self, save_file=""):
        self.save_file = save_file

        self.log = ""

        # world data (generated by LLM)
        self.world = {}
        self.locations = {}
        self.npcs = {}

        # player progress
        self.clues_found = []
        self.truth_fragments_found = []
        self.suspect_scores = {}

        # turn control
        self.day = 1
        self.actions_left = 2

        self.ended = False
        return

    def save(self):
        data = {
            "log": self.log,
            "world": self.world,
            "locations": self.locations,
            "npcs": self.npcs,
            "clues_found": self.clues_found,
            "truth_fragments_found": self.truth_fragments_found,
            "suspect_scores": self.suspect_scores,
            "day": self.day,
            "actions_left": self.actions_left,
            "ended": self.ended,
        }
        write_json(self.save_file, data, indent=2)
        return

    def load(self):
        data = read_json(self.save_file)
        self.log = data["log"]
        self.world = data["world"]
        self.locations = data["locations"]
        self.npcs = data["npcs"]
        self.clues_found = data["clues_found"]
        self.truth_fragments_found = data["truth_fragments_found"]
        self.suspect_scores = data["suspect_scores"]
        self.day = data["day"]
        self.actions_left = data["actions_left"]
        self.ended = data["ended"]
        return


# -------------------- Game --------------------
class Game:
    def __init__(self, config):
        self.static_dir = config.static_dir
        self.state_dir = config.state_dir
        self.output_dir = config.output_dir
        self.summary_file = ""

        self.gpt = GPT(config.model)
        self.gpt4 = GPT("gpt-4")

        self.user_prompt_to_text = {}
        self.max_saves = 4
        self.state = State()

        # load user prompt text
        user_prompt_dir = os.path.join(self.static_dir, "user_prompt")
        filename_list = os.listdir(user_prompt_dir)
        for filename in filename_list:
            user_prompt = filename[:-4]
            user_prompt_file = os.path.join(user_prompt_dir, filename)
            self.user_prompt_to_text[user_prompt] = read_txt(user_prompt_file)

        # load LLM task prompts
        self.prompt_world_gen = read_txt(os.path.join(self.static_dir, "prompt_world_gen.txt"))
        self.prompt_narration = read_txt(os.path.join(self.static_dir, "prompt_narration.txt"))
        self.prompt_npc_dialog = read_txt(os.path.join(self.static_dir, "prompt_npc_dialog.txt"))
        self.prompt_state_update = read_txt(os.path.join(self.static_dir, "prompt_state_update.txt"))
        self.prompt_review = read_txt(os.path.join(self.static_dir, "prompt_review.txt"))
        return

    def run_start(self):
        # get start type
        user_prompt = self.user_prompt_to_text["start"]
        while True:
            text_in = input(user_prompt)
            if text_in == "1":
                start_type = "new"
                break
            elif text_in == "2":
                start_type = "load"
                break

        # get save file usage
        save_list_text = "\n存檔列表：\n"
        saveid_to_exist = {}
        for i in range(self.max_saves):
            save_id = str(i + 1)
            save_file = os.path.join(self.state_dir, f"save_{save_id}.json")
            if os.path.exists(save_file):
                saveid_to_exist[save_id] = True
                save_list_text += f"({save_id}) 舊有存檔\n"
            else:
                saveid_to_exist[save_id] = False
                save_list_text += f"({save_id}) 空白存檔\n"

        # get save file
        user_prompt = f"{save_list_text}\n使用存檔欄位： "
        while True:
            text_in = input(user_prompt)
            if start_type == "new":
                if text_in in saveid_to_exist:
                    use_save_id = text_in
                    break
            else:
                if saveid_to_exist.get(text_in, False):
                    use_save_id = text_in
                    break

        # initialize state
        self.summary_file = os.path.join(self.output_dir, f"summary_{use_save_id}.txt")
        use_save_file = os.path.join(self.state_dir, f"save_{use_save_id}.json")
        self.state = State(use_save_file)

        if start_type == "new":
            opening_base = self.user_prompt_to_text["opening"]

            # ---- Task1 世界生成 ----
            world_json = self.gpt4.run_gpt(self.prompt_world_gen, 1400)
            self.state.world = json.loads(world_json)
            # ---------------------- 補丁：自動修正 LLM 輸出 ----------------------
            # 修正 npcs 若為 list → dict
            if isinstance(self.state.world.get("npcs"), list):
                fixed_npcs = {}
                for idx, npc in enumerate(self.state.world["npcs"]):
                    # 嘗試從 name 欄位取得 NPC 名稱，若沒有就自動產生
                    npc_name = npc.get("name", f"NPC_{idx+1}")

                    # 其餘欄位放到 dict 裡
                    npc_data = {k: v for k, v in npc.items() if k != "name"}

                    fixed_npcs[npc_name] = npc_data

                self.state.world["npcs"] = fixed_npcs

            # 修正 locations 若為 list → dict
            if isinstance(self.state.world.get("locations"), list):
                fixed_locations = {}
                for idx, loc in enumerate(self.state.world["locations"]):
                    loc_name = loc.get("name", f"地點_{idx+1}")
                    loc_data = {k: v for k, v in loc.items() if k != "name"}
                    fixed_locations[loc_name] = loc_data

                self.state.world["locations"] = fixed_locations
            # ---------------------------------------------------------------------
            self.state.locations = self.state.world["locations"]
            self.state.npcs = self.state.world["npcs"]
            self.state.suspect_scores = {k: 0.0 for k in self.state.npcs.keys()}

            opening_scene = self.state.world["opening_scene"]
            user_prompt = opening_base + "\n\n" + opening_scene

            input(user_prompt + "\n\n開始旅程(按換行繼續)... ")
            self.state.log += user_prompt + "\n"
            self.state.save()
        else:
            self.state.load()

        self.run_loop()
        return

    def get_action(self):
        user_prompt = (
            f"\n=== Day {self.state.day} | 剩餘行動 {self.state.actions_left} ===\n"
            "輸入你的行動（help 看範例）：\n> "
        )
        text_in = input(user_prompt).strip()
        return text_in

    def run_loop(self):
        day_limit = self.state.world.get("day_limit", 5)

        while True:
            if self.state.ended:
                break
            if self.state.day > day_limit:
                self.do_end()
                break

            action_text = self.get_action()

            if action_text == "exit":
                break
            if action_text == "help":
                print(self.user_prompt_to_text.get("help", ""))
                continue

            if action_text.startswith("詢問"):
                self.do_talk_to_npc(action_text)
            elif action_text.startswith("調查") or action_text.startswith("前往"):
                self.do_investigate(action_text)
            elif action_text.startswith("推理"):
                self.do_reason()
            elif action_text.startswith("指控"):
                self.do_accuse(action_text)
            else:
                print("看不懂你的指令，輸入 help 可查看範例。")
                continue

            # expend action point
            self.state.actions_left -= 1
            if self.state.actions_left <= 0:
                self.state.day += 1
                self.state.actions_left = 2
                print("\n--- 這一天結束，城市發出細碎的重置聲 ---\n")

            self.state.save()
        return

    # --------------- Actions ---------------

    def do_investigate(self, action_text):
        # Task2 narration
        prompt = self.prompt_narration.format(
            state=self.state_to_json(),
            action=action_text
        )
        narration = self.gpt4.run_gpt(prompt, 450)
        print("\n" + narration + "\n")
        self.state.log += f"\n[行動]{action_text}\n{narration}\n"

        # Task4 state update (digest)
        upd_prompt = self.prompt_state_update.format(
            state=self.state_to_json(),
            narration=narration,
            npc_reply=""
        )
        upd_out = self.gpt4.run_gpt(upd_prompt, 900)
        self.load_new_state_from_update(upd_out)

    def do_talk_to_npc(self, action_text):
        # 格式：詢問 NPC名 關於 問題
        try:
            _, npc_name, _, question = action_text.split(" ", 3)
        except:
            print("格式錯誤，請用：詢問 NPC名 關於 問題")
            return
        if npc_name not in self.state.npcs:
            print("沒有這個 NPC。可先用 推理/調查 取得名字。")
            return

        npc_data = json.dumps(self.state.npcs[npc_name], ensure_ascii=False)
        prompt = self.prompt_npc_dialog.format(
            npc_name=npc_name,
            npc_data=npc_data,
            state=self.state_to_json(),
            question=question
        )
        reply = self.gpt4.run_gpt(prompt, 350)
        print("\n" + reply + "\n")
        self.state.log += f"\n[詢問]{npc_name}：{question}\n{reply}\n"

        upd_prompt = self.prompt_state_update.format(
            state=self.state_to_json(),
            narration="(玩家與 NPC 對話)",
            npc_reply=reply
        )
        upd_out = self.gpt4.run_gpt(upd_prompt, 900)
        self.load_new_state_from_update(upd_out)

    def do_reason(self):
        action_text = "推理（整理目前線索）"
        prompt = self.prompt_narration.format(
            state=self.state_to_json(),
            action=action_text
        )
        narration = self.gpt4.run_gpt(prompt, 450)
        print("\n" + narration + "\n")
        self.state.log += f"\n[推理]\n{narration}\n"

        upd_prompt = self.prompt_state_update.format(
            state=self.state_to_json(),
            narration=narration,
            npc_reply=""
        )
        upd_out = self.gpt4.run_gpt(upd_prompt, 900)
        self.load_new_state_from_update(upd_out)

    def do_accuse(self, action_text):
        try:
            _, npc_name = action_text.split(" ", 1)
        except:
            print("格式錯誤，請用：指控 NPC名")
            return
        self.state.log += f"\n[指控]{npc_name}\n"
        print(f"\n你指控了 {npc_name} ... 城市的裂縫開始收束。\n")
        self.do_end(accused=npc_name)

    # --------------- End / Review ---------------

    def do_end(self, accused=""):
        self.state.ended = True

        story = re.sub(r"\n+", "\n", self.state.log).strip()
        final_state_json = self.state_to_json(pretty=True)

        review_in = (
            "【遊戲 log】\n" + story +
            "\n\n【final_state】\n" + final_state_json +
            ("\n\n【玩家指控】\n" + accused if accused else "") +
            "\n\n" + self.prompt_review
        )
        review = self.gpt4.run_gpt(review_in, 1400)

        write_txt(self.summary_file, review)
        print("\n===== 本次冒險回顧 =====\n")
        print(review)

        self.state.save()
        return

    # --------------- Helpers ---------------

    def state_to_json(self, pretty=False):
        data = {
            "log": self.state.log[-2000:],  # 避免太長
            "world": self.state.world,
            "locations": self.state.locations,
            "npcs": self.state.npcs,
            "clues_found": self.state.clues_found,
            "truth_fragments_found": self.state.truth_fragments_found,
            "suspect_scores": self.state.suspect_scores,
            "day": self.state.day,
            "actions_left": self.state.actions_left,
            "ended": self.state.ended,
        }
        if pretty:
            return json.dumps(data, ensure_ascii=False, indent=2)
        return json.dumps(data, ensure_ascii=False)

    def load_new_state_from_update(self, upd_out):
        json_start = upd_out.find("{")
        if json_start == -1:
            print("狀態更新失敗（沒有 JSON），略過。")
            return
        try:
            new_state = json.loads(upd_out[json_start:])
        except:
            print("狀態 JSON 解析失敗，略過。")
            return

        self.state.world = new_state.get("world", self.state.world)
        self.state.locations = new_state.get("locations", self.state.locations)
        self.state.npcs = new_state.get("npcs", self.state.npcs)
        self.state.clues_found = new_state.get("clues_found", self.state.clues_found)
        self.state.truth_fragments_found = new_state.get("truth_fragments_found", self.state.truth_fragments_found)
        self.state.suspect_scores = new_state.get("suspect_scores", self.state.suspect_scores)
        self.state.day = new_state.get("day", self.state.day)
        self.state.actions_left = new_state.get("actions_left", self.state.actions_left)
        self.state.ended = new_state.get("ended", self.state.ended)
        return


# -------------------- main --------------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--config_file", type=str, default="lab2_config.json")
    arg = parser.parse_args()

    openai.api_key = input("OpenAI API Key: ")

    config = Config(arg.config_file)
    game = Game(config)
    game.run_start()
    return


if __name__ == "__main__":
    main()
    sys.exit()
